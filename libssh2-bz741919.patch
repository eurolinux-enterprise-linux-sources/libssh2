From 6a031e7c272ef5bc9ff6429c8c45eaad4cba510d Mon Sep 17 00:00:00 2001
From: Daniel Stenberg <daniel@haxx.se>
Date: Mon, 15 Feb 2010 00:12:10 +0100
Subject: [PATCH 1/8] free "outbuf" when killing a session

Fix memoary leak: if there was an "output" still allocated when a
session was torn down it needs to be freed in session_free()

Patch by Yoichi Iwaki in bug #2929647

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/session.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/src/session.c b/src/session.c
index b222798..0317937 100644
--- a/src/session.c
+++ b/src/session.c
@@ -684,6 +684,7 @@ session_free(LIBSSH2_SESSION *session)
     LIBSSH2_PACKET *pkg;
     LIBSSH2_CHANNEL *ch;
     LIBSSH2_LISTENER *l;
+    struct transportpacket *p = &session->packet;
 
     if (session->free_state == libssh2_NB_state_idle) {
         _libssh2_debug(session, LIBSSH2_DBG_TRANS, "Freeing session resource",
@@ -905,6 +906,11 @@ session_free(LIBSSH2_SESSION *session)
         LIBSSH2_FREE(session, pkg);
     }
 
+    /* Cleanup remaining outgoing packet buffer */
+    if (p->outbuf) {
+        LIBSSH2_FREE(session, p->outbuf);
+    }
+
     if(session->socket_prev_blockstate)
         /* if the socket was previously blocking, put it back so */
         session_nonblock(session->socket_fd, 0);
-- 
1.7.4.4


From f8b0ff17a50470f21bf09d3e7c3b0508e0ae6406 Mon Sep 17 00:00:00 2001
From: Alexander Lamaison <awl03@doc.ic.ac.uk>
Date: Sun, 7 Mar 2010 16:18:46 +0000
Subject: [PATCH 2/8] Fix memory leak in libssh2_knownhost_add.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/knownhost.c |   10 +++++++---
 1 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/knownhost.c b/src/knownhost.c
index 409ef29..ddbddb4 100644
--- a/src/knownhost.c
+++ b/src/knownhost.c
@@ -151,9 +151,13 @@ libssh2_knownhost_add(LIBSSH2_KNOWNHOSTS *hosts,
     if(!entry)
         return rc;
 
-    if(!(typemask & LIBSSH2_KNOWNHOST_KEY_MASK))
-        /* make sure we have a key type set */
-        return LIBSSH2_ERROR_INVAL;
+    /* make sure we have a key type set */
+    if(!(typemask & LIBSSH2_KNOWNHOST_KEY_MASK)) {
+        rc = LIBSSH2_ERROR_INVAL;
+        libssh2_error(hosts->session, LIBSSH2_ERROR_INVAL,
+                      "No key type set", /* should_free */ 0);
+        goto error;
+    }
 
     memset(entry, 0, sizeof(struct known_host));
 
-- 
1.7.4.4


From 8bfd70dc344756757689676ad00d8faad5175f22 Mon Sep 17 00:00:00 2001
From: Daniel Stenberg <daniel@haxx.se>
Date: Tue, 23 Mar 2010 23:16:08 +0100
Subject: [PATCH 3/8] fix memory leak

we must not assign the pointer a NULL since it keeps allocated
data and at least parts of an error string

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/scp.c |    8 +++-----
 1 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/src/scp.c b/src/scp.c
index e861bf4..7b0254a 100644
--- a/src/scp.c
+++ b/src/scp.c
@@ -1016,12 +1016,10 @@ scp_send(LIBSSH2_SESSION * session, const char *path, int mode,
                  */
                 LIBSSH2_FREE(session, session->scpSend_err_msg);
                 session->scpSend_err_msg = NULL;
-                goto scp_send_error;
             }
-
-            libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,
-                          session->scpSend_err_msg, 1);
-            session->scpSend_err_msg = NULL;
+            else
+                libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,
+                              "failed waiting for ACK", /* should_free */ 0);
             goto scp_send_error;
         }
     }
-- 
1.7.4.4


From f15fffc91625f83f2126d73267b581f7ae38a469 Mon Sep 17 00:00:00 2001
From: Peter Stuge <peter@stuge.se>
Date: Wed, 23 Jun 2010 11:16:02 +0200
Subject: [PATCH 4/8] Fix message length bugs in libssh2_debug()

There was a buffer overflow waiting to happen when a debug message was
longer than 1536 bytes.

Thanks to Daniel who spotted that there was a problem with the message
length passed to a trace handler also after commit
0f0652a3093111fc7dac0205fdcf8d02bf16e89f.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/misc.c |   16 +++++++++-------
 1 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/src/misc.c b/src/misc.c
index 806dfb9..6d5937b 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -316,7 +316,7 @@ void
 _libssh2_debug(LIBSSH2_SESSION * session, int context, const char *format, ...)
 {
     char buffer[1536];
-    int len;
+    int len, buflen = sizeof(buffer);
     va_list vargs;
     struct timeval now;
     static int firstsec;
@@ -345,15 +345,17 @@ _libssh2_debug(LIBSSH2_SESSION * session, int context, const char *format, ...)
     }
     now.tv_sec -= firstsec;
 
-    len = snprintf(buffer, sizeof(buffer), "[libssh2] %d.%06d %s: ",
+    len = snprintf(buffer, buflen, "[libssh2] %d.%06d %s: ",
                    (int)now.tv_sec, (int)now.tv_usec, contexts[context]);
 
-    va_start(vargs, format);
-    len += vsnprintf(buffer + len, 1535 - len, format, vargs);
-    buffer[len] = '\n';
-    va_end(vargs);
-    write(2, buffer, len + 1);
+    if (len < buflen) {
+        buflen -= len;
+        va_start(vargs, format);
+        len = vsnprintf(buffer + len, buflen, format, vargs);
+        va_end(vargs);
+    }
 
+    fprintf(stderr, "%s\n", buffer);
 }
 
 #else
-- 
1.7.4.4


From 7e42939af2c57d06d1d0daf458504b9e8519d00e Mon Sep 17 00:00:00 2001
From: Tor Arntsen <tor@spacetec.no>
Date: Wed, 23 Jun 2010 11:15:34 +0200
Subject: [PATCH 5/8] Don't overflow MD5 server hostkey

Use SHA_DIGEST_LENGTH and MD5_DIGEST_LENGTH in memcpy instead of hardcoded
values. An incorrect value was used for MD5.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/libgcrypt.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/libgcrypt.h b/src/libgcrypt.h
index b972c35..08d4e4c 100644
--- a/src/libgcrypt.h
+++ b/src/libgcrypt.h
@@ -63,7 +63,7 @@
 #define libssh2_sha1_init(ctx) gcry_md_open (ctx,  GCRY_MD_SHA1, 0);
 #define libssh2_sha1_update(ctx, data, len) gcry_md_write (ctx, data, len)
 #define libssh2_sha1_final(ctx, out) \
-  memcpy (out, gcry_md_read (ctx, 0), 20), gcry_md_close (ctx)
+  memcpy (out, gcry_md_read (ctx, 0), SHA_DIGEST_LENGTH), gcry_md_close (ctx)
 #define libssh2_sha1(message, len, out) \
   gcry_md_hash_buffer (GCRY_MD_SHA1, out, message, len)
 
@@ -71,7 +71,7 @@
 #define libssh2_md5_init(ctx) gcry_md_open (ctx,  GCRY_MD_MD5, 0);
 #define libssh2_md5_update(ctx, data, len) gcry_md_write (ctx, data, len)
 #define libssh2_md5_final(ctx, out) \
-  memcpy (out, gcry_md_read (ctx, 0), 20), gcry_md_close (ctx)
+  memcpy (out, gcry_md_read (ctx, 0), MD5_DIGEST_LENGTH), gcry_md_close (ctx)
 #define libssh2_md5(message, len, out) \
   gcry_md_hash_buffer (GCRY_MD_MD5, out, message, len)
 
-- 
1.7.4.4


From 8d111ef23147af099515a0ba7ed7c634f862b6f0 Mon Sep 17 00:00:00 2001
From: John Little <john@cityc.co.uk>
Date: Thu, 1 Jul 2010 19:56:06 +0200
Subject: [PATCH 6/8] session_free: free more data to avoid memory leaks

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/kex.c     |    3 +++
 src/session.c |    9 +++++++++
 2 files changed, 12 insertions(+), 0 deletions(-)

diff --git a/src/kex.c b/src/kex.c
index edcf1b6..a518f08 100644
--- a/src/kex.c
+++ b/src/kex.c
@@ -1117,6 +1117,9 @@ static int kexinit(LIBSSH2_SESSION * session)
     } else {
         data = session->kexinit_data;
         data_len = session->kexinit_data_len;
+	/* zap the variables to ensure there is NOT a double free later */
+        session->kexinit_data = NULL;
+        session->kexinit_data_len = 0;
     }
 
     rc = _libssh2_transport_write(session, data, data_len);
diff --git a/src/session.c b/src/session.c
index 0317937..aefc86f 100644
--- a/src/session.c
+++ b/src/session.c
@@ -792,6 +792,9 @@ session_free(LIBSSH2_SESSION *session)
         LIBSSH2_FREE(session, session->hostkey_prefs);
     }
 
+    if (session->local.kexinit) {
+        LIBSSH2_FREE(session, session->local.kexinit);
+    }
     if (session->local.crypt_prefs) {
         LIBSSH2_FREE(session, session->local.crypt_prefs);
     }
@@ -805,6 +808,9 @@ session_free(LIBSSH2_SESSION *session)
         LIBSSH2_FREE(session, session->local.lang_prefs);
     }
 
+    if (session->remote.kexinit) {
+        LIBSSH2_FREE(session, session->remote.kexinit);
+    }
     if (session->remote.crypt_prefs) {
         LIBSSH2_FREE(session, session->remote.crypt_prefs);
     }
@@ -821,6 +827,9 @@ session_free(LIBSSH2_SESSION *session)
     /*
      * Make sure all memory used in the state variables are free
      */
+    if (session->kexinit_data) {
+        LIBSSH2_FREE(session, session->kexinit_data);
+    }
     if (session->startup_data) {
         LIBSSH2_FREE(session, session->startup_data);
     }
-- 
1.7.4.4


From 5cd937deea11e272958d31d9f204504c8cf5428c Mon Sep 17 00:00:00 2001
From: Jasmeet Bagga <jasmeetbagga@gmail.com>
Date: Tue, 2 Nov 2010 00:02:25 +0100
Subject: [PATCH 7/8] kex_agree_hostkey: fix NULL pointer derefence

While setting up the session, ssh tries to determine the type of
encryption method it can use for the session. This requires looking at
the keys offered by the remote host and comparing these with the methods
supported by libssh2 (rsa & dss). To do this there is an iteration over
the array containing the methods supported by libssh2.

If there is no agreement on the type of encryption we come to the 3rd
entry of the hostkeyp array. Here hostkeyp is valid but *hostkep is
NULL. Thus when we dereference that in (*hostkeyp)->name there is a
crash

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/kex.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/kex.c b/src/kex.c
index a518f08..c0a24a7 100644
--- a/src/kex.c
+++ b/src/kex.c
@@ -1255,7 +1255,7 @@ static int kex_agree_hostkey(LIBSSH2_SESSION * session,
         return -1;
     }
 
-    while (hostkeyp && (*hostkeyp)->name) {
+    while (hostkeyp && (*hostkeyp) && (*hostkeyp)->name) {
         s = kex_agree_instr(hostkey, hostkey_len,
                             (unsigned char *) (*hostkeyp)->name,
                             strlen((*hostkeyp)->name));
-- 
1.7.4.4


From c6b60f93d124e551eb45ec94a3d2b709101d8acd Mon Sep 17 00:00:00 2001
From: Alexander Lamaison <awl03@doc.ic.ac.uk>
Date: Tue, 23 Feb 2010 19:27:55 +0000
Subject: [PATCH 8/8] Fix LIBSSH2_ALLOC checks.

These appear to be cut-and paste errors where the wrong variable is checked
for NULLness after calling LIBSSH2_ALLOC.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 src/knownhost.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/knownhost.c b/src/knownhost.c
index ddbddb4..6a63200 100644
--- a/src/knownhost.c
+++ b/src/knownhost.c
@@ -167,7 +167,7 @@ libssh2_knownhost_add(LIBSSH2_KNOWNHOSTS *hosts,
     case LIBSSH2_KNOWNHOST_TYPE_PLAIN:
     case LIBSSH2_KNOWNHOST_TYPE_CUSTOM:
         entry->name = LIBSSH2_ALLOC(hosts->session, hostlen+1);
-        if(!entry)
+        if(!entry->name)
             goto error;
         memcpy(entry->name, host, hostlen+1);
         break;
@@ -196,7 +196,7 @@ libssh2_knownhost_add(LIBSSH2_KNOWNHOSTS *hosts,
         if(!keylen)
             keylen = strlen(key);
         entry->key = LIBSSH2_ALLOC(hosts->session, keylen+1);
-        if(!entry)
+        if(!entry->key)
             goto error;
         memcpy(entry->key, key, keylen+1);
         entry->key[keylen]=0; /* force a terminating zero trailer */
-- 
1.7.4.4

